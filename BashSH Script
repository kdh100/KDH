1. Shell CMD
	* grep $OPTION $PATTERN $FILE
		- -i : 대소문자 상관없이
		- -v : 제외
		- -n : 라인 넘버
		- -l : 파일 리스트
		- -w : 단어 지정
	* 정규 표현식(regular expression; regex)
		- * : 앞 문자를 0번 이상 반복
		- . : 1문자
		- ? : 앞 문자를 0(없거나)~1(있거나) 반복
		- {m} : 앞 문자가 m 번 반복
		- {m,n} : 앞 문자가 m 번 이상 n 번 이하 반복
		- [abc] : 선택적인 1문자
		- [^a] : 제외시킬 1문자
		- ^root : 라인의 처음 매칭
		- root$ : 라인의 끝 매칭
	* fgrep(grep -F), egrep(grep -E)
	* sed $OPTION 'address|/pattern/CMD' $FILE
		- -n : 전체 정보 미출력
		- -i : 치환된 출력을 현재 파일에 바로 적용
		- address : 범위(ex_ 1,3 or 3)
		- /pattern/ : 정규 표현식 사용가능
			\ 패턴 내 변수를 사용할 경우 ''(single) 이 아닌 ""(double) 을 사용
		- CMD
			# p : 출력
			# d : 제외하고 출력(-n 같이 쓰면 출력값 없음)
			# s///g : 치환(address's'/검색/치환/g)
				~ g : 전역 치환, 검색 패턴에 대해 행,열 모두 치환됨
				~ pattern 내 문자열에 / 가 포함된 경우 #, ; 으로 pattern 구분 가능
	* awk $OPTIOM $STATEMENT '{action}' $FILE
		- -F# : 필드 구분자
		- $# : 0 은 전체, 1* 은 필드 번호
		- 'regex' 를 사용하여 특정 검색(=grep)할 수 있음
		- action 내 문자열 등 사용 시 "" 사용
		- action 내 필드 구분은 , 혹은 "" 사용
		- statement : regex 형식의 패턴, Condition 등...(C 언어 형식)
	* sort $OPTION $FILE (+ uniq CMD)
		- -u : 중복값이 있을 경우 한번만 출력
		- -r : 오름차순 정렬
		- -n : 숫자값 기준 정렬
		- uniq
			# -d : 중복값만 출력
			# -u : 단독값만 출력
	* cut $OPTIOM $FILE
		- -c($-$) : 숫자 범위만큼의 문자만 출력
			# 앞의 범위 생략시 1 부터 시작
			# 뒤의 범위 생략시 앞의 범위만큼 생략하고 나머지 출력
		- -d : 필드 구분자
		- -f : 필드 번호
	* tr "검색문자" "변환문자"
		- 검색문자의 길이를 기준으로 변환문자가 1:1 대칭되어 변환
	* split -d -l $NUM $FILE
		- 파일을 읽어 지정한 라인 개수 만큼 파일을 분리하여 새로 저장(현재 디렉토리)
		- -d : 10진수 
			# 저장되는 신규 파일의 이름 형식을 10진수 형태로 생성
		- -l : 라인 개수
	* paste $FILE1 $FILE2
		- 파일1 과 파일2 의 내용을 열(column) 방식으로 붙여서 출력
	* head|tail $OPTION $FILE
		- 출력 내용의 최상단 라인 기준 라인 개수만큼(기본 라인개수 10개)만 출력
		- -n : 라인 개수
			# -N : 최상단 라인 기준에서 개수만큼만 표시
			# head -n +N : 마지막 라인 기준에서 개수만큼 제외하고 표시
			# tail -n +N : 최상단 라인 기준에서 개수만큼 제외하고 표시
	* wc $OPTION $FILE
		- -l : 파일의 총 행(line) 개수
		- -w : 파일의 총 단어(word) 개수
		- -c : 파일의 총 문자(character) 개수
	* Redirection
		- stdin(keyboard input) : 0
			# mailx -s "[ OK ] server1" admin@example.com < report.txt
		- stdout(screen output) : 1
			# ps -ef | grep httpd | wc -l > httpd.count
		- stderr(screen error message output) : 2
			# find / -name core -type f 2>/dev/null
	* Pipe
		- CMD | CMD
		- 앞의 CMD 결과를 뒤의 CMD 인자로 입력
			# fsck -y /dev/sdb1 2>&1 | tee -a fsck.log
				~ tee : 출력값을 파일로 생성
				~ -a : 내용 추가
2. Variable(변수)
	* 변수 종류
		- 지역변수 : VAR=5
		- 환경변수 : export VAR=5
		- 특수변수 : $, ?, !, *, #, @, ...
	* 변수 선언
		- 선언 : VAR=5 ; export VAR
			# 현재 쉘 뿐만 아니라 다른 쉘에서도 해당 변수가 적용됨
		- 확인 : echo $VAR
			# 선언된 변수는 사용 시 반드시 변수 앞에 '$' 추가
		- 해제 : unset VAR
	* 특수변수
		- $$ : 현재 PID 번호(ex_ 임시파일 생성 시 사용)
		- $! : 바로 이전에 수행된 백그라운드 프로세스 PID 번호
		- $? : 바로 이전에 수행된 명령어의 return 값(0 ~ 255; 0 은 정상종료)
		- $*, $@ : 모든 인자
		- $# : 인자 개수
		- $0 : 프로그램 이름
		- $'N' : 'N'째 인자
	* 메타캐릭터(Metacharacter)
		- '' : 쉘이 해석할 수 없도록 차단
		- "" : 쉘이 해석할 수 없도록 차단(except $, ``, \)
		- `` : CMD
		- \ : escape character
		- ; : 한 라인에 여러개의 CMD 수행
	* 별칭(Alias)
		- alias $NAME='CMD'
		- alias $NAME
		- unalias $NAME
	* 대표적인 환경파일
		- /etc/profile
		- ~/.bash_profile
		- ~/.bashrc
	* Here Documentation """ cat CMD + << """
		- 내용이 많은 text 형태의 파일 생성 시
		- 선택 메뉴 형식의 내용을 출력해야 할 때
			# cat << EOF > test.c
			  main() { printf("Hello world\n" }
			  EOF
	* 그룹화(Grouping)
		- CMD 의 내용들을 하나로 묶어 하나의 입력값으로 출력
			# cd ~ ; tar cvf - . | (cd /backup ; tar xvf -)
			# yum update -y || exit 1
	* 조건부실행(Condition Execution)
		- &&(AND) : 앞의 결과값이 참이면 실행
			# cd /test && rm -rf *
		- ||(OR) : 앞의 결과값이 참이면 종료, 참이 아니라면 실행
			# [ -f /etc/passwd ] && echo "OK" || echo "FAIL"
				~ 조건문은 '[,]' 으로 묶어서 선언
	* 경로(File/Directory Path)
		- 등록된 변수의 경로와 파일 이름을 분리하여 출력
		- dirname $DIR : 등록된 변수의 경로 출력
		- basename $DIR : 등록된 변수의 파일 출력
			# DIR1=/etc/passwd
			# echo $(dirname $DIR1)/$(basename $DIR1) = /etc/passwd
	* 재평가(Evaluation)
		- 해석이 안되는 구문을 원래의 CMD 가 정상 해석 할 수 있게 한 번 재해석하여 결과를 원래 CMD 에 올려줌
		- eval CMD + other CMD
			# A=B ; B=C
			# echo $A ; echo $B
			# echo $$A = (expect) $(B) -> C | (output) 'present shell PID' + A
			# eval echo \$$A
				~ eval interpreted -> echo \$(B)
				~ bash interpreted -> echo $B = C
3. vscode
	* Installation
		- Microsoft GPG key import
			# rpm --import https://packages.microsoft.com/keys/microsoft.asc
		- repolist create
			# vi /etc/yum.repos.d/vscode.repo
			  [code]
			  name=Visual Studio Code
			  baseurl=https://packages.microsoft.com/yumrepos/vscode
			  enabled=1
			  gpgcheck=1
			  gpgkey=https://packages.microsoft.com/keys/microsoft.asc
		- package install
			# yum install code -y
		- vscode run
			# cd ; mkdir -p vscode/shellproject
			# code --no-sandbox --user-date-dir="/root/vscode"
				~ vi ~/.bashrc
				~ alias code='code --no-sandbox --user-date-dir="/root/vscode"'
				~ . ~/.bashrc
	* Setting
		- 작업 공간 선택
			# Open Folder > /root/vscode/shellproject
		- 확장 프로그램 설치
			# Shell Debug, Code Runner, Shellcheck, shellman
			# Korean Language Pack for Visual Studio Code
4. Shell Script
	* 스크립트는 반복 작업을 쉽고 편하게 하기 위해 프로그래밍된 파
	* 실행 방법
		- bash -x test.sh
			# 서브 shell 실행시켜 그 위에서 스크립트를 실행
			# 읽기 권한만 있어도 실행 가능
		- . test.sh(= source test.sh)
			# 현재 shell 위에서 스크립트를 실행
			# 읽기 권한만 있어도 실행 가능
		- chmod 755 test.sh && . test.sh
			# 권한 변경하여 사용
			# 매직넘버가 포함된 스크립트 사용시 권한 변경 필수
	* PATH 변수 설정
		- vi ~/.bash_profile
			# PATH=$PATH:/root/vscode/shellproject(:$LOCATE; 추가하고싶다면 콜론을 붙여 경로 추가 지정)
			# export PATH
	* 매직넘버(#!/bin/bash)
		- 커널에게 실행 프로그램으로 인식시키는 구문, 항상 스크립트 첫 행에 있어야함
	* 주석(comment)
		- # : 한 줄 주석
		- : << EOF ~ EOF : 여러 줄 주석
	* echo CMD
		- 내용 출력
			# echo -n "current time : " ; date
				~ -n : 개행문자 무시, 뒤의 date 는 아래 행에 출력되어야 하지만 echo 와 같은 행에서 출력됨
	* read CMD
		- 입력(input) 받아오기
			# read $ : stdin 을 변수($) 에 저장
			# read $ $ $ : stdin 의 단어들을 각 변수($) 에 순서대로 저장하고 나머지는 마지막 변수($) 에 저장
	* expr CMD
		- 정수 산술 연산
			# expr $ +|-|\*|/ 2
				~ 소수값은 버림
	* test(= [ ]) CMD
		- 식을 평가 후 논리값 반환, 종료 상태가 0 이면 TRUE, 0 이 아니면 FALSE
			# [ -f /etc/passwd ]
			# test -f /etc/passwd
			# 파일 연산자
				~ -f : 파일
				~ -d : 디렉토리
				~ -s : not null
				~ -r|w|x : r|w|x 권한
			# 문자열 연산자
				~ = : 같다
				~ != : 같지 않다
				~ -z : 길이가 0
				~ -n : 길이가 1 이상 (= ! -z string)
			# 산술 연산자 """ expr """
				~ -eq : 같다
				~ -ne : 같지 않다
				~ -lt : 미만
				~ -le : 이하
				~ -gt : 초과
				~ -ge : 이상
				~ -a : AND
				~ -o : OR
			# 논리 부정 연산자(NOT)
				~ ! -z string
		- 연산자 우선순위는 " () > ! > -a > -o "
5. 조건문(if, case)
	* if 조건문
		- 예문
			if condition1; then
				statement
			elif condition2; then
				statement
			else
				:
			fi
	* case 조건문
		- 예문
			case $VAR in
				1) context ;;
				2) context 
			   	   context ;;
				3 | 3 | 3) context;;
				*) context ;;
					echo "asdfasdf"
					exit 1 ;;
			esac
6. 반복문(for, while, untile)	
	* for 반복문
		- 범위가 정해져있을 때
		- 예문
			for $VAR in $VARLIST
			do
				context
			done
	* while 반복문
		- 범위가 정해져있지 않을때
		- 예문
			while $CONDITION
			do
				context
			done
		- shift CMD 와 같이 사용
			while [ $# -gt 0 ]
			do
				echo "$# : $*"
				shift
			done
7. 루프 제어
	* shift CMD
		- 인자를 하나씩 줄여가는 명령어
		- 기본값 1, 인자값에 따라 그만큼 왼쪽에서 오른쪽으로 줄여감
	* break CMD
		- 반복 구문에서 바로 done 으로 탈출하여 종료시키는 명령어
	* continue CMD
		- 조건에 부합하면 상위 조건으로 다시 돌려보내는 명령어
			# continue 1 이면 현재조건(3) 바로 전의 조건(2), 2 이면 또 그 위의 조건(1)
8. 함수(function)
	* 선언
		- fun() { CMD; CMD; }
		- function fun { CMD; CMD; }
	* 확인
		- typeset -f
	* 실행
		- fun
	* 해제
		- unset -f fun
9. 시그널 트랩(Signal Trapping)
	* 시그널을 무시하거나, 특정 시그널에 맞춰 내가 원하는 동작을 하게끔 제어(Signal Control)
	* 시그널 무시
		- trap ' ' 2 9 15
		- trap 'echo "<Ctrl + C> will not terminate."' 2











