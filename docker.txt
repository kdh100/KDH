1. 시스템 기반 기초 지식
    * 클라우드 : 인터넷를 통해 컴퓨팅 리소스(서버,스토리지 등)를 주문형(On-Demand)으로 제공
        - IaaS(Infrastructure as a Service)
        - PaaS(Platform as a Service)
        - SaaS(Service as a Service)
        - FaaS(Function as a Service)
2. 인프라 구성 관리 기초 지식
    * IaC(Infrastructure as a Code) : 인프라 구성/관리를 코드를 통해서 진행
    * CI/CD(Continuous Integration/Delivery&Deployment; 지속적 통합/배포)
        - CI : 소스코드 작성(build) + 테스트 + 이미지 생성(merge)
        - CD : 내부 저장소에 이미지 전달(Delivery) + 이미지 배포(Deployment)
3. 실습을 위한 OS 준비
    * WMware Workstation
    * CentOS
    * 기본 설정 및 스냅샷
        - docker1|2 : 192.168.10.10|20/24, (gw)192.168.10.2, (dns)192.168.10.2
        - hostnamectl set-hostname docker{1|2}.example.com
        - reboot
4. Docker
    * Image : 파일시스템과 실행할 어플리케이션 및 설정을 하나로 합친 것
        - 컨테이너를 생성하는 템플릿 역할
    * Container : 이미지를 기반으로 생성되는 파일시스템과 어플리케이션이 구체화되어 실행되는 상태
    * Build : 이미지를 생성
    * Ship : 이미지를 공유(퍼블릭 레지스트리)
        - 기본값으로 도커 공개저장소(https://hub.docker.com) 지정
            # Github, Bitbucket 등 사용 가능
    * Run : 이미지를 동작시켜 컨테이너를 생성
    * Component
        - Engine
            # client
            # REST API
            # daemon
        - Ojbect
            # Image/Container
            # Network(NAT; masquerading/port-forwarding)
            # volume
            # plugins
        - Registry
        - Compose
        - Swarm
5. Docker 기술
    * 'chroot + namespace + cgroup'
        - chroot : 파일시스템 구획(최상위 폴더를 제한하여 실행되는 범위를 지정)
        - namespace : 시스템자원 라벨링(특정 컨테이너가 사용할 수 있는 라벨을 지정하기)
        - cgroup : 자원의 제한 설정
    * 네트워크(가상 브리지/가상 NIC)
        - 도커 설치 시 서버의 물리 NIC 가 docker0 이라는 가상 브리지에 연결(기본값)
        - 컨테이너가 실행되면 172.17.0.0/16 이라는 서브넷 사설주소가 eth0 에 자동 할당
6. Docker 설치
    * 직접 설치
        <yum 설정매니저 설치>
        - yum install -y yum-utils
        - yum-config-manager --add-repo \
          https://download.docker.com/linux/centos/docker-ce.repo
        <중복 패키지 삭제>
        - yum remove -y runc
        <도커 설치>
        - yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin
        <도커 서비스 시작>
        - systemctl enable --now docker
        <도커 실행>
        - docker run hello-world
    * 스크립트를 사용한 설치
        <중복 패키지 삭제>
        - yum remove -y runc
        <스크립트 다운로드>
        - curl -fsSL https://test.docker.com -o test-docker.sh
        - ./test-docker.sh
        <도커 서비스 시작>
        - systemctl enable --now docker
        <도커 실행>
        - docker run hello-world
7. Docker 관리
    * 이미지
        - search : 검색
        - pull : 다운로드
            # Docker Image Repository(Local Registry)
            # Private Registry
            # Public Registry
                ~ 도커 허브
        - images : 이미지 목록 확인
            # '레지스트리/사용자명' 안붙어있는 이미지는 도커 허브 공식(Official) 이미지
            # '태그' 안붙어있는 이미지는 최신(Latest) 이미지
        - inspect : 자세한 내용 확인
            # docker inspect nginx
            # docker inspect -f "{{ .Config.Env }}" nginx
                ~ Go 언어(jinja2) 방식의 필터(-f; filter)를 통해 원하는 정보만 출력
        - rmi : 이미지 삭제
            # docker rmi $(docker images -q) : 모든 이미지 삭제
        - push : 업로드
            1) 이미지를 '아이디/이름:태그' 형식으로 생성
            2) 도커 허브 로그인
            3) 이미지 푸시
        - tag : 태그 설정
            # 하드 링크 형식으로 새로운 이미지 생성됨
        - login : 허브(퍼블릭 레지스트리) 로그인
            # https://hub.docker.com
            # /root/.docker/config.json 파일에 base64 방식으로 ID/PW 저장됨
                ~ 보안에 매우 취약(https://www.base64decode.org/)
    * 컨테이너
        - create -d --name webserver -p 80:80 nginx : 컨테이너 생성(pull + create)
            # --name : 컨테이너 이름
                ~ 해당 옵션이 없으면 자동으로 이름 생성됨
            # -d : 백그라운드 실행
            # -p : 서비스 포트 매칭(Port-Forwarding)
                ~ '외부포트:내부포트'
                ~ 해당 옵션이 없으면 외부에 포트 공개가 안되서 서비스 불가
        - rename <OLD> <NEW> : 컨테이너 이름 변경
        - run -d -it --rm --name myos1 centos : 컨테이너 시작(pull + create + start)
            # --rm : 컨테이너 종료 시 자동으로 삭제
            # -it : 표준 입출력 추가(키보드+모니터; 포어그라운드 실행)
                ~ OS 컨테이너는 기본 쉘 실행이며, -it 옵션 없으면 컨테이너가 중지상태 유지됨
                ~ 모든 OS 이미지는 기본값으로 백그라운드로 컨테이너 실행
        - ps -aq : 컨테이너 목록 확인
            # -a : 모든 정보(활성화 + 비활성화)
            # -q : ID 정보만 출력
        - rm -f : 컨테이너 삭제
            # docker rm -f $(docker ps -aq) : 모든 컨테이너 삭제
    * 볼륨(컨테이너를 위한 영구적인 저장 공간)
        - volume : 지정 위치(/var/lib/docker) 공간 일부를 컨테이너가 사용(Over-Lay 방식)
            # 일반적인 상황에서 가장 보편적인 방식
            # docker run -v [testvol:]/usr/share/nginx/html:ro... 
                ~ 볼륨 이름 생략 가능, 볼륨 생략하면 자동 생성
                ~ ':ro' 마운트 포인트의 권한 옵션 부여 가능
            # volume create : 볼륨 생성
            # volume ls : 볼륨 목록 확인
            # volume rm : 볼륨 삭제
                ~ 컨테이너 삭제 시 '-v' 옵션 추가(rm -f -v)하면 자동생성 볼륨도 같이 삭제됨
        - bind mount : 도커 호스트 내 공간 일부를 컨테이너가 사용(Over-Mount 방식)
            # 특정 임의의 저장공간이 필요한 경우(공유 NAS, DB Storage 등) 사용
            # docker run -v /web:/usr/share/nginx/html:ro...
                ~ 볼륨 이름 필수, 디렉토리가 없으면 자동 생성
    * 네트워크
        - SDN(Software Defined Network)를 사용하여 컨테이너 통신 관리
        - 172.17.0.0/16 기본 할당되어 게이트웨이는 172.17.0.1/16 사용
        - 네트워크 드라이브
            # bridge : 가상 스위치
            # host : 원본 호스트의 네트워크 사용
            # none : 할당 없음(내부망 목적)
            # overlay : 다중 도커 bridge 를 하나로 묶어서 단일 네트워크로 설정(스웜 기능)
        - network
            # ls : 목록 확인
            # inspect : 자세한 정보 확인
            # connect|disconnect : 네트워크에 연결|연결해제
            # create : 사용자 정의 네트워크 생성
                ~ --driver : 네트워크 드라이브 지정
                ~ --subnet : 서브넷 지정(CIDR; /24 or VLSM; 255.255.255.0)
                ~ --gateway : 게이트웨이 지정
            # prune|rm : 미사용중인 네트워크 삭제|삭제
        - container run CMD 의 네트워크 옵션
            # --network mynet : 네트워크를 선택하여 컨테이너에 연결
            # --ip 172.17.0.3 : 컨테이너에 할당시킬 호스트 아이피 지정
            # --link mysql:mysql : <컨테이너이름>:<별칭> 설정으로 이름 통신 가능
            # --dns : DNS 서버 지정
            # --add-host : /etc/hosts 등록하는것처럼 호스트 매핑 설정
            # --hostname : 컨테이너의 호스트명 지정
8. Docker 운영
    [컨테이너 운영]
    * attach : 컨테이너의 실행중인 프로세스에 연결(입출력 연결)
        - 연결한 프로세스에서 빠져나올때(detach)는 "Ctrl + P + Q" 로 빠져나와야함
           # exit 로 빠져나오면 프로세스 자체가 종료됨
        - 'exec -it' 와 동일함
           # 'exec /bin/bash' : 추가 프로세스를 가동하여 접근했기 때문에 exit 가능
    * cp : 파일 복사
        - 컨테이너 --> 호스트 : web:/usr/share/nginx/html/index.html /tmp/index.html
        - 호스트 --> 컨테이너 : /tmp/index2.html web:/usr/share/nginx/index2.html
    * diff : 원본 이미지와 현재 컨테이너의 차이점 확인
        - A(add), C(changed), D(delete)
    * logs -ft ID : 컨테이너(ID) 로그 확인
        - -f : 지속적으로 로그 확인(tail 과 동일)
        - -t : timestamp 확인
            # /var/lib/docker/containers 하위에 '.json.log' 로그 파일
    * top : 컨테이너 프로세스 상태 확인
        - aux : 프로세스 상태 확인 표기 정보 변경
    * port : 컨테이너 포트 노출(-p 를 통해 설정한 port-forwarding) 상태 확인
    * kill : 비정상 강제종료(9번 시그널; 15번 정상종료=stop)
    [불필요한 데이터 삭제]
    * docker image|container|network|volume|system prune
        - docker system prune -af : 모든 불필요한 데이터(이미지,컨테이너 등) 삭제
    [리소스 제한 및 모니터링]
    * 리소스 제한
        - 메모리(단위: b, k, m, g) : 'run' 옵션으로 설정
            # --memory 500m : 컨테이너의 최대 메모리 사용 제한
                ~ 제한 넘으면 kill
            # --memory-reservation 500m : 컨테이너의 최소 메모리 사용 보장
            # --memory-swap 1g : 컨테이너의 SWAP 메모리(SWAP 설정 - 할당 메모리 = 설정값)
                ~ -m 500m --memory-swap 1g --> 1g - 500m = swap '500m'
            # --oom-disable : 제한 넘으면 kill 기능 OFF
        - CPU
            # --cpu 1 : 코어 개수 설정
                ~ 1개의 코어만큼만 사용(100% 사용)
            # --cpu-shares 2048 : CPU 가중치(컨테이너 별 상대적인 가중치) 설정
                ~ 기본값 1024, 2배 더 중요하게 처리
            # --cpuset-cpus 0-3 : 여러개의 CPU 중 담당하는 CPU 지정
                ~ 0번부터 3번 CPU 할당
        - BLOCK I/O
            # --blkio-weight[-device] : 저장소 입출력 쿼터(quota) 설정, 100 - 1000 범위 지정
                ~ 기본값 500
            # --device-read|write-bps:100mb : 저장소 읽기/쓰기 작업량 제한(kb, mb, gb)
            # --device-read|write-iops:100 : 저장소 읽기/쓰기 작업량 제한 쿼터 설정(iops * blk_size)
    * 리소스 모니터링
        - stats: 런타임 통계 확인
        - events -f : 실시간 이벤트 정보 출력
9. Docker 이미지 생성
    * containner commit : 컨테이너 --> 이미지 생성
        - docker commit <opt> <container> <repository/image:tag>
            # -a : 제작자
            # -m : 설명
        - 컨테이너에서 작업한 내용들로 용량이 너무 커졌을 때
            # multi-stage build 방식 적용
                ~ 최초 빌드 작업 후 나오는 최종 파일만을 다른 컨테이너로 옮겨서 재빌드
        - 직접 컨테이너에서 명령어 실행을 많이 해야할 때
            # dockerfile 사용
    * container export : 컨테이너 --> fs.tar 생성(fs)
        - docker export <opt> <container> <fs.tar>
            # > : 기본 umask 설정값의 퍼미션 지정(0644; -rw-r--r--)
            # -o : docker 에 의한 최소 퍼미션 지정(0600; -rw-------)
    * image import : fs.tar --> 이미지 생성(fs)
        - docker import <fs.tar> <site/repository/image:tag>
            # 생성할 이미지의 이름을 지정하지 않으면 dangling image(none) 로 생성되므로 주의
                ~ prune 으로 삭제 가능
    * image save : 이미지 --> fs.tar 생성(layer)
        - docker save -o <fs.tar> <repository/image:tag>
    * image load : fs.tar --> 이미지(layer)
        - docker load -i <fs.tar>
10. Dockerfile
    * 기본 구문
        - FROM : 베이스가 될 docker 이미지
        - COPY : 호스트 --> 이미지 소스 코드 복사
        - RUN : 컨테이너 안에서 수행할 명령
        - ENV : 환경 변수 등 설정
        - CMD : 컨테이너 안에서 작동시킬 데몬 실행
    * 작업 순서
        1) mkdir -p Dockerfile Dockerfile/public-html
        2) vi Dockerfile
        ----------------
        FROM httpd:2.4
        COPY ./public-html/ /usr/local/apache2/htdocs/
        ----------------
        3) docker build -t my-apache2 .
            # 도퍼 파일이 존재하는 폴더(.)에서 작업하거나 도커 파일이 존재하는 경로를 지정
            # 도커 파일은 정해진 이름(Docker|docker)을 따르거나, -f 옵션으로 특정 도커 파일 지정
                ~ docker build -t my-apache2 -f Docker2 .
            # 도커 파일은 tar 형태의 이미지로도 빌드 가능
                ~ docker build -t my-apache2 - < Docker.tar.gz
        4) docker images
        5) docker run -dit --name my-running-app -p 8080:80 my-apache2
        6) docker ps -a
        7) curl http://localhost:8080
