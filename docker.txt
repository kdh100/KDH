1. 시스템 기반 기초 지식
    * 클라우드 : 인터넷를 통해 컴퓨팅 리소스(서버,스토리지 등)를 주문형(On-Demand)으로 제공
        - IaaS(Infrastructure as a Service)
        - PaaS(Platform as a Service)
        - SaaS(Service as a Service)
        - FaaS(Function as a Service)
2. 인프라 구성 관리 기초 지식
    * IaC(Infrastructure as a Code) : 인프라 구성/관리를 코드를 통해서 진행
    * CI/CD(Continuous Integration/Delivery&Deployment; 지속적 통합/배포)
        - CI : 소스코드 작성(build) + 테스트 + 이미지 생성(merge)
        - CD : 내부 저장소에 이미지 전달(Delivery) + 이미지 배포(Deployment)
3. 실습을 위한 OS 준비
    * WMware Workstation
    * CentOS
    * 기본 설정 및 스냅샷
        - docker1|2 : 192.168.10.10|20/24, (gw)192.168.10.2, (dns)192.168.10.2
        - hostnamectl set-hostname docker{1|2}.example.com
        - reboot
    * 환경설정(.bashrc, .vimrc)
      <Docker alias>
      alias irm='docker rmi $(docker images -q)'
      alias crm='docker rm -f $(docker ps -aq)'
      alias vrm='docker volume prune -f'
      alias nrm='docker network prune -f'
      alias dockerc='docker-compose $*'
      alias up='docker-compose up -d'
      alias down='docker-compose down -v'
      <vim>
      syntax on
      autocmd FileType yaml setlocal ts=2 sw=2 st=2 ai nu et
      autocmd FileType python setlocal ts=2 sw=2 st=2 ai nu et
4. Docker
    * Image : 파일시스템과 실행할 어플리케이션 및 설정을 하나로 합친 것
        - 컨테이너를 생성하는 템플릿 역할
    * Container : 이미지를 기반으로 생성되는 파일시스템과 어플리케이션이 구체화되어 실행되는 상태
    * Build : 이미지를 생성
    * Ship : 이미지를 공유(퍼블릭 레지스트리)
        - 기본값으로 도커 공개저장소(https://hub.docker.com) 지정
            # Github, Bitbucket 등 사용 가능
    * Run : 이미지를 동작시켜 컨테이너를 생성
    * Component
        - Engine
            # client
            # REST API
            # daemon
        - Ojbect
            # Image/Container
            # Network(NAT; masquerading/port-forwarding)
            # volume
            # plugins
        - Registry
        - Compose
        - Swarm
5. Docker 기술
    * 'chroot + namespace + cgroup'
        - chroot : 파일시스템 구획(최상위 폴더를 제한하여 실행되는 범위를 지정)
        - namespace : 시스템자원 라벨링(특정 컨테이너가 사용할 수 있는 라벨을 지정하기)
        - cgroup : 자원의 제한 설정
    * 네트워크(가상 브리지/가상 NIC)
        - 도커 설치 시 서버의 물리 NIC 가 docker0 이라는 가상 브리지에 연결(기본값)
        - 컨테이너가 실행되면 172.17.0.0/16 이라는 서브넷 사설주소가 eth0 에 자동 할당
6. Docker 설치
    * 직접 설치
        <yum 설정매니저 설치>
        - yum install -y yum-utils
        - yum-config-manager --add-repo \
          https://download.docker.com/linux/centos/docker-ce.repo
        <중복 패키지 삭제>
        - yum remove -y runc
        <도커 설치>
        - yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin
        <도커 서비스 시작>
        - systemctl enable --now docker
        <도커 실행>
        - docker run hello-world
    * 스크립트를 사용한 설치
        <중복 패키지 삭제>
        - yum remove -y runc
        <스크립트 다운로드>
        - curl -fsSL https://test.docker.com -o test-docker.sh
        - ./test-docker.sh
        <도커 서비스 시작>
        - systemctl enable --now docker
        <도커 실행>
        - docker run hello-world
7. Docker 관리
    * 이미지
        - search : 검색
        - pull : 다운로드
            # Docker Image Repository(Local Registry)
            # Private Registry
            # Public Registry
                ~ 도커 허브
        - images : 이미지 목록 확인
            # '레지스트리/사용자명' 안붙어있는 이미지는 도커 허브 공식(Official) 이미지
            # '태그' 안붙어있는 이미지는 최신(Latest) 이미지
        - inspect : 자세한 내용 확인
            # docker inspect nginx
            # docker inspect -f "{{ .Config.Env }}" nginx
                ~ Go 언어(jinja2) 방식의 필터(-f; filter)를 통해 원하는 정보만 출력
        - rmi : 이미지 삭제
            # docker rmi $(docker images -q) : 모든 이미지 삭제
        - push : 업로드
            1) 이미지를 '아이디/이름:태그' 형식으로 생성
            2) 도커 허브 로그인
            3) 이미지 푸시
        - tag : 태그 설정
            # 하드 링크 형식으로 새로운 이미지 생성됨
        - login : 허브(퍼블릭 레지스트리) 로그인
            # https://hub.docker.com
            # /root/.docker/config.json 파일에 base64 방식으로 ID/PW 저장됨
                ~ 보안에 매우 취약(https://www.base64decode.org/)
    * 컨테이너
        - create -d --name webserver -p 80:80 nginx : 컨테이너 생성(pull + create)
            # --name : 컨테이너 이름
                ~ 해당 옵션이 없으면 자동으로 이름 생성됨
            # -d : 백그라운드 실행
            # -p : 서비스 포트 매칭(Port-Forwarding)
                ~ '외부포트:내부포트'
                ~ 해당 옵션이 없으면 외부에 포트 공개가 안되서 서비스 불가
        - rename <OLD> <NEW> : 컨테이너 이름 변경
        - run -d -it --rm --name myos1 centos : 컨테이너 시작(pull + create + start)
            # --rm : 컨테이너 종료 시 자동으로 삭제
            # -it : 표준 입출력 추가(키보드+모니터; 포어그라운드 실행)
                ~ OS 컨테이너는 기본 쉘 실행이며, -it 옵션 없으면 컨테이너가 중지상태 유지됨
                ~ 모든 OS 이미지는 기본값으로 백그라운드로 컨테이너 실행
        - ps -aq : 컨테이너 목록 확인
            # -a : 모든 정보(활성화 + 비활성화)
            # -q : ID 정보만 출력
        - rm -f : 컨테이너 삭제
            # docker rm -f $(docker ps -aq) : 모든 컨테이너 삭제
    * 볼륨(컨테이너를 위한 영구적인 저장 공간)
        - volume : 지정 위치(/var/lib/docker) 공간 일부를 컨테이너가 사용(Over-Lay 방식)
            # 일반적인 상황에서 가장 보편적인 방식
            # docker run -v [testvol:]/usr/share/nginx/html:ro... 
                ~ 볼륨 이름 생략 가능, 볼륨 생략하면 자동 생성
                ~ ':ro' 마운트 포인트의 권한 옵션 부여 가능
            # volume create : 볼륨 생성
            # volume ls : 볼륨 목록 확인
            # volume rm : 볼륨 삭제
                ~ 컨테이너 삭제 시 '-v' 옵션 추가(rm -f -v)하면 자동생성 볼륨도 같이 삭제됨
        - bind mount : 도커 호스트 내 공간 일부를 컨테이너가 사용(Over-Mount 방식)
            # 특정 임의의 저장공간이 필요한 경우(공유 NAS, DB Storage 등) 사용
            # docker run -v /web:/usr/share/nginx/html:ro...
                ~ 볼륨 이름 필수, 디렉토리가 없으면 자동 생성
    * 네트워크
        - SDN(Software Defined Network)를 사용하여 컨테이너 통신 관리
        - 172.17.0.0/16 기본 할당되어 게이트웨이는 172.17.0.1/16 사용
        - 네트워크 드라이브
            # bridge : 가상 스위치
            # host : 원본 호스트의 네트워크 사용
            # none : 할당 없음(내부망 목적)
            # overlay : 다중 도커 bridge 를 하나로 묶어서 단일 네트워크로 설정(스웜 기능)
        - network
            # ls : 목록 확인
            # inspect : 자세한 정보 확인
            # connect|disconnect : 네트워크에 연결|연결해제
            # create : 사용자 정의 네트워크 생성
                ~ --driver : 네트워크 드라이브 지정
                ~ --subnet : 서브넷 지정(CIDR; /24 or VLSM; 255.255.255.0)
                ~ --gateway : 게이트웨이 지정
            # prune|rm : 미사용중인 네트워크 삭제|삭제
        - container run CMD 의 네트워크 옵션
            # --network mynet : 네트워크를 선택하여 컨테이너에 연결
            # --ip 172.17.0.3 : 컨테이너에 할당시킬 호스트 아이피 지정
            # --link mysql:mysql : <컨테이너이름>:<별칭> 설정으로 이름 통신 가능
            # --dns : DNS 서버 지정
            # --add-host : /etc/hosts 등록하는것처럼 호스트 매핑 설정
            # --hostname : 컨테이너의 호스트명 지정
8. Docker 운영
    [컨테이너 운영]
    * attach : 컨테이너의 실행중인 프로세스에 연결(입출력 연결)
        - 연결한 프로세스에서 빠져나올때(detach)는 "Ctrl + P + Q" 로 빠져나와야함
           # exit 로 빠져나오면 프로세스 자체가 종료됨
        - 'exec -it' 와 동일함
           # 'exec /bin/bash' : 추가 프로세스를 가동하여 접근했기 때문에 exit 가능
    * cp : 파일 복사
        - 컨테이너 --> 호스트 : web:/usr/share/nginx/html/index.html /tmp/index.html
        - 호스트 --> 컨테이너 : /tmp/index2.html web:/usr/share/nginx/index2.html
    * diff : 원본 이미지와 현재 컨테이너의 차이점 확인
        - A(add), C(changed), D(delete)
    * logs -ft ID : 컨테이너(ID) 로그 확인
        - -f : 지속적으로 로그 확인(tail 과 동일)
        - -t : timestamp 확인
            # /var/lib/docker/containers 하위에 '.json.log' 로그 파일
    * top : 컨테이너 프로세스 상태 확인
        - aux : 프로세스 상태 확인 표기 정보 변경
    * port : 컨테이너 포트 노출(-p 를 통해 설정한 port-forwarding) 상태 확인
    * kill : 비정상 강제종료(9번 시그널; 15번 정상종료=stop)
    [불필요한 데이터 삭제]
    * docker image|container|network|volume|system prune
        - docker system prune -af : 모든 불필요한 데이터(이미지,컨테이너 등) 삭제
    [리소스 제한 및 모니터링]
    * 리소스 제한
        - 메모리(단위: b, k, m, g) : 'run' 옵션으로 설정
            # --memory 500m : 컨테이너의 최대 메모리 사용 제한
                ~ 제한 넘으면 kill
            # --memory-reservation 500m : 컨테이너의 최소 메모리 사용 보장
            # --memory-swap 1g : 컨테이너의 SWAP 메모리(SWAP 설정 - 할당 메모리 = 설정값)
                ~ -m 500m --memory-swap 1g --> 1g - 500m = swap '500m'
            # --oom-disable : 제한 넘으면 kill 기능 OFF
        - CPU
            # --cpu 1 : 코어 개수 설정
                ~ 1개의 코어만큼만 사용(100% 사용)
            # --cpu-shares 2048 : CPU 가중치(컨테이너 별 상대적인 가중치) 설정
                ~ 기본값 1024, 2배 더 중요하게 처리
            # --cpuset-cpus 0-3 : 여러개의 CPU 중 담당하는 CPU 지정
                ~ 0번부터 3번 CPU 할당
        - BLOCK I/O
            # --blkio-weight[-device] : 저장소 입출력 쿼터(quota) 설정, 100 - 1000 범위 지정
                ~ 기본값 500
            # --device-read|write-bps:100mb : 저장소 읽기/쓰기 작업량 제한(kb, mb, gb)
            # --device-read|write-iops:100 : 저장소 읽기/쓰기 작업량 제한 쿼터 설정(iops * blk_size)
    * 리소스 모니터링
        - stats: 런타임 통계 확인
        - events -f : 실시간 이벤트 정보 출력
9. Docker 이미지 생성
    * containner commit : 컨테이너 --> 이미지 생성
        - docker commit <opt> <container> <repository/image:tag>
            # -a : 제작자
            # -m : 설명
        - 컨테이너에서 작업한 내용들로 용량이 너무 커졌을 때
            # multi-stage build 방식 적용
                ~ 최초 빌드 작업 후 나오는 최종 파일만을 다른 컨테이너로 옮겨서 재빌드
        - 직접 컨테이너에서 명령어 실행을 많이 해야할 때
            # dockerfile 사용
    * container export : 컨테이너 --> fs.tar 생성(fs)
        - docker export <opt> <container> <fs.tar>
            # > : 기본 umask 설정값의 퍼미션 지정(0644; -rw-r--r--)
            # -o : docker 에 의한 최소 퍼미션 지정(0600; -rw-------)
    * image import : fs.tar --> 이미지 생성(fs)
        - docker import <fs.tar> <site/repository/image:tag>
            # 생성할 이미지의 이름을 지정하지 않으면 dangling image(none) 로 생성되므로 주의
                ~ prune 으로 삭제 가능
    * image save : 이미지 --> fs.tar 생성(layer)
        - docker save -o <fs.tar> <repository/image:tag>
    * image load : fs.tar --> 이미지(layer)
        - docker load -i <fs.tar>
10. Dockerfile
    * 빌드 절차
        1) mkdir -p Dockerfile Dockerfile/public-html
        2) vi Dockerfile
        ----------------
        FROM httpd:2.4
        COPY ./public-html/ /usr/local/apache2/htdocs/
        ----------------
        3) docker build -t my-apache2 .
            # 도퍼 파일이 존재하는 폴더(.)에서 작업하거나 도커 파일이 존재하는 경로를 지정
            # 도커 파일은 정해진 이름(Docker|docker)을 따르거나, -f 옵션으로 특정 도커 파일 지정
                ~ docker build -t my-apache2 -f Docker2 .
            # 도커 파일은 tar 형태의 이미지로도 빌드 가능
                ~ docker build -t my-apache2 - < Docker.tar.gz
        4) docker images
            # docker image history <image> : 빌드된 이미지 내 작업 목록 확인
        5) docker run -dit --name my-running-app -p 8080:80 my-apache2
        6) docker ps -a
        7) curl http://localhost:8080
    * 기본 구문
        - FROM : 베이스가 될 docker 이미지
        - RUN : 컨테이너 안에서 수행할 명령
            # shell : RUN yum install -y nginx
            # exec : RUN ["/bin/bash", "-c", "yum install -y nginx"]
                ~ -c : string 형태를 실행 코드로 인식(yaml 형식으로 작성되기 때문에 필수)
        - ENV : 환경 변수 등 설정
        - CMD : 컨테이너 안에서 작동시킬 데몬 실행
            # shell : CMD nginx -g 'daemon off;'
            # exec : CMD ["nginx", "-g", "daemon off;"]
                ~ 변경 가능한 조건 실행(run 실행 시 CMD 인수를 우선 실행)
        - ENTRYPOINT : shell 형식, exec 형식 모두 사용 가능
            # 변경 불가능한 무조건 실행
            # ENTRYPOINT 에서 명령어를, CMD 에서 명령어의 옵션과 인수를 지정하여 혼합 사용
                ~ ENTRYPOINT top
                  CMD ["-d", "10"]
        - ONBUILD : 이미 빌드화된 이미지를 재빌드할 때 실행할 명령어
            # ADD, RUN 사용 가능
        - WORKDIR : 작업용 디렉토리 지정(기본값: /)
            # ENV 로 변수 지정하여 해당 환경 변수와 같이 혼합하여 사용하는 걸 권장
        - USER : 사용자 지정
            # USER <사용자명>:<그룹명>
        - ADD/COPY : 이미지에 호스트에 있는 파일, 디렉토리를 추가
            # ADD <호스트 파일경로> <Docker 이미지 파일경로> --> yaml 형식 변환 가능
                ~ <호스트 파일경로> 를 지정하면 안에 내용만 복사
                  만약 파일이라면 COPY 랑 동일, 아카이브 파일이면 해제해서 내용만 추가
            # COPY <호스트 파일경로> <Docker 이미지 파일경로> --> yaml 형식 변환 가능
                ~ OS 간 이동은 지원하지 않음, 간단한 복사에만 사용 권장
        - LABEL : 이미지 버전, 작성자, 설명글 작성
            # LABEL <title|version|description...=value>
                ~ docker image inspect -f "{{ .Config.Lables }}" <image>
        - EXPOSE : 리스닝 포트 지정(컨테이너를 실행할 작업자에게 공개 포트 안내 목적)
            # 기본값은 tcp
        - VOLUME : 영구 볼륨 저장
            # VOLUME ["<마운트포인트>"]
                ~ 컨테이너 내 마운트포인트 디렉토리 경로를 지정하고
                ~ run -v 옵션을 통해서 volume 형식이나 bind-mount 형식으로 지정해줘야함
11. 레지스트리
    * 용어 정리
        - 로컬 레지스트리 : 내컴퓨터 내 레지스트리
            # SSL/TLS 사용하지 않으니 외부 접근 제한시킬 것
        - 프라이빗 레지스트리 : 사내망 내 레지스트리
            # 로컬 레지스트리 + SSL/TLS 인증을 통한 보안 강화로 허용된 인원들만 접근 가능
        - 퍼블릭 레지스트리 : 도커허브, 구글 클라우드, AWS 등
12. Docker Compose
    * 다중 컨테이너를 정의하고 실행하기 위한 도구, GO 언어로 만들어졌으며, .yaml 파일로 서비스 구성
        - docker-compose != docker compose
            # docker-compose : 도커 패키지에 포함되는 기본 명령어
            # docker compose : 명령어를 다운로드받아 사용하는 것
    * 설치(안정화버전, v2.12.0(2022.10.25))
        - wget https://github.com/docker/compose/releases/download/v2.12.0/docker-compose-linux-x86_64 \
          -O /usr/local/bin/docker-compose
    * '.yaml' 파일 문법
        - 주석 : #
        - 들여쓰기 : 2칸 또는 4칸(space)
        - 데이터 : Key:Value 형식
        - 배열 : '-' 로 표시하고 공백 한 칸 이상 존재해야함
        - boolean : true/false(yes/no)
            # 소문자 형식 권장
        - int : 정수,실수를 따옴표 없이 사용하면 숫자형(int) 데이터
            # 따옴표 사용시 문자형(str) 데이터
        - 줄바꿈 : '|' 는 마지막 문자열 뒤 줄바꿈(\n) 포함, '>' 는 중간에 들어간 줄바꿈 제외
    * 최상위 요소(top-level-elements)
        - 버전(version:) : docker-compose 파일 버전
        - 이름(name:) : 프로젝트 이름(디렉토리 이름으로 사용됨)
            # 미지정 시 자동 생성, 미지정 권장
                ~ docker-compose 를 통해서 기동할 경우 다른 서비스 이름으로 접근 가능
                ~ docker inspect 로 확인해보면 네트워크 부분에 별칭(Alias) 걸려있음 확인 가능
                ~ docker run 을 통해서 기동할 경우 지정한 이름으로 접근해야함
        - 서비스(services:) : 동작할 리소스 정의
        - 네트워크(networks:) : 네트워크 이름(신규 네트워크 이름으로 사용됨)
            # 미지정 시 자동 생성, 미지정 권장
        - 볼륨(volumes:) : 볼륨 이름(신규 볼륨 이름으로 사용됨)
            # 미지정 시 자동 생성, 미지정 권장
        - 컨피그(configs:) : 컨테이너 서비스 구성 파일 지정
            # 볼륨처럼 작동함
        - 비밀(secrets:) : 민감한 정보를 암호화하여 구성 파일 지정
    * 이미지 빌드 예시(image, build)
        services:
          webserver:
            images: ubuntu|asashinho/dockersample:1.0
            build: .|/data/Dockerfile-alternate
              context: /data
              dockerfile: Dockerfile-alternate
              args:
                projectno: 1
                users: sktuser
    * 컨테이너 내부 동작 명령어 지정(command, entrypoint)
        services:
          webserver:
            command: /bin/bash
            entrypoint:(배열 순서대로 실행)
                - php
                - -d
                - memory_limit=-1
    * 컨테이너 간 연결(links)
        services:
          webserver:
            links:
              - logserver:log01(서비스명:앨리어스명)
    * 컨테이너 간 통신(ports, expose)
        services:
          webserver:
            ports:
              - "3000"(컨테이너의 포트 번호만 지정하면 호스트 머신의 포트는 랜덤 부여)
              - "8000:8000"
              - "49100:22"
              - "127.0.0.1:8001:8001"
            expose:
              - "3000"(호스트 내부에서만 접근 가능)
    * 서비스 의존 관계 정의(depends_on)
        services:
          webserver:
            build: .
            depends_on:(1순위 db, 2순위 redis, 마지막 webserver 순서로 기동)
              - db
              - redis
          redis:
            image: redis
          db:
            image: postgres
    * 환경변수 지정(environment, env_file)
        services:
          webserver:
            environment:
              # 배열(array) 방식
              - HOGE=fuga
              - FOO
              # 해시(hash) 방식
              HOGE: fuga
              FOO:
            env_file: envfile(HOGE=fuga)
    * 컨테이너 정보 설정(container_name, labels)
        container_name: web-container(직접 컨테이너 이름 지정하지말고 자동 생성을 권장)
        labels:(라벨 확인은 docker-compose config 에서 가능)
          - "com.example.description=Accounting webapp"
          - "com.example.departement=Finance"
    * 컨테이너 볼륨 관리(volumes)
        services:
          webserver:
            volumes:
              - /var/lib/mysql
              - dbvol:/var/lib/mysql:ro
              - cache/:/tmp/cache(bind-mount)
    * 컨테이너 서비스 재시작(restart)
        services:
          webserver:
            restart: always(정책이 제거될 때까지 항상 컨테이너를 다시 시작)
    [참고] VI/VIM 편집기를 통한 YAML 파일 편집 시 유효한 설정값(vi ~/.vimrc)
    syntax on --> 구문 강조
    autocmd FileType yaml setlocal ts=2 sw=2 st=2 ai nu et
    autocmd FileType python setlocal ts=2 sw=2 st=2 ai nu et
    --> FileType : 특정 파일 형식만 적용
        setlocal : 현재 편집기에서만 설정 변경
        ts : TAB 칸 수
        sw : 자동 들여쓰기 TAB 칸 수
        st : TAB 공백 수
        ai : 자동 들여쓰기
        nu : 라인 번호 표기
        et : TAB --> space 변환
    * Docker-compose CMD
        - version : 버전 확인
        - up : 컨테이너 실행
            # -d : 백그라운드로 실행
            # --build : 이미지 빌드 후 컨테이너 실행
            # --scale <서비스명=숫자> : 숫자 만큼 컨테이너 실행
        - down : 컨테이너 중지
            # -v : 자동 생성되었던 볼륨 삭제
        - start|stop|pause|unpause|restart : 시작|중지|일시중지|재개|재시작
        - kill : 강제 중지(default: 9)
            # -s : 시그널 전송
                ~ HUP(1; 접속 중지)
                ~ SIGINT(2; 실행 중지)
                ~ SIGKILL(9; 강제 중지)
                ~ SIGTERM(15; 정상 중지)
        - rm : 컨테이너 삭제
            # -f : 강제 삭제
        - port : 포트 바인딩
            # docker-compose port <서비스> <포트>
        - run : 임의의 명령어 실행
            # docker-compose run centos /bin/bash = docker exec -it centos /bin/bash
        - config : 서비스 구성 확인
        - ps : 상태 확인
            # --format : JSON 포맷으로 확인
                ~ docker-compose ps --format json | jq .
        - logs: 로그 확인
13. Docker 참고사항
    * 캐시 무효화(혹은 버전 고정)
        - debian 계열의 OS 로 가동되는 경우 apt-get 을 통한 패키지 관리 시 캐싱 데이터로 인해 오류 발생 가능
            # apt-get update && apt-get install -y 를 항상 묶어서 사용하는 걸 권장
                ~ 캐시가 남아있을 경우 업데이트가 진행되지 않아 구버전으로 다운로드될 가능성 있음
                ~ 혹은, 패키지의 태그를 이용해 고정된 버전을 명시해주면 위 문제점 상쇄 가능
        - /var/lib/apt/lists 를 지우면 이미지 빌드 시 레이어에 캐싱 데이터가 들어가지 않아 크기 감소 효과
            # 공식 debian, ubuntu 이미지들은 자동으로 'apt-get clean' 하기 때문에 굳이 호출하지 않아도 됨
    * 빌드킷(Buildkit)    
        - 도커 이미지를 효율적으로 빌드하기 위한 모듈
            # 도커 데스크톱의 모든 사용자들에게 기본값으로 사용중
            # 리눅스에서 도커를 기동할 경우, 환경변수 또는 기본설정변경을 통해 빌드킷 활성화 진행
                ~ 환경변수) DOCKER_BUILDKIT=1 docker build...
                ~ 기본설정) /etc/docker/daemon.json --> {\n\t"features":{"buildkit" : true}\n}
    * 이미지 태그 의미
        - stretch, buster, jessie : Debian 코드
            # bullseye, bookworm : Debian 테스트용 코드(불안정할 수 있음)
        - slim : 실행을 위한 최소 코드 포함
        - alpine : 컨테이너 내부용 리눅스 운영체제, 이미지를 가능한 작게 만들기 위해 사용하는 코드
        - windowsservercore : 윈도우 서버 기반 코드